from collections import Counter
from datetime import datetime
import os
import logging
import csv
import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import Font, PatternFill, Alignment
from openpyxl.utils.dataframe import dataframe_to_rows
import xlsxwriter
from session import session_manager
from db import connect_to_db, fetch_student_by_index_number, fetch_all_records # For fetching data for reports
from grade_util import calculate_grade, calculate_gpa, get_grade_point # For GPA calculation in reports
from fpdf import FPDF # For PDF generation

logger = logging.getLogger(__name__)

def get_report_header_info():
    """get report header information based on current session"""
    current_user = session_manager.get_current_user()
    if current_user:
        username = current_user['username']
        role = current_user['role']
        full_name = current_user.get('user_data', {}).get('full_name', username)
        return {
            'generated_by': f"{full_name} ({role})",
            'username': username,
            'role': role,
            'generation_time': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'session_duration': f"{session_manager.get_session_duration():.1f} minutes"
        }
    else:
        return {
            'generated_by': "System User",
            'username': "unknown",
            'role': "unknown", 
            'generation_time': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'session_duration': "N/A"
        }

logger.info("Processing records for display...")

# Modularized data processing logic
def process_student_profile(record):
    """Process individual student profile - Fixed field mapping."""
    return {
        'index_number': record.get('index_number', 'unknown'),
        'name': record.get('full_name', 'N/A'),  # Fixed: was looking for 'name' but should be 'full_name'
        'full_name': record.get('full_name', 'N/A'),  # Added for consistency
        'program': record.get('program', 'N/A'),
        'year_of_study': record.get('year_of_study', 'N/A'),
        'dob': record.get('dob', 'N/A'),
        'gender': record.get('gender', 'N/A'),
        'contact_email': record.get('contact_email', 'N/A')
    }

def process_student_grades(record):
    """Process individual student grades."""
    return {
        'course_code': record.get('course_code', 'N/A'),
        'score': record.get('score', 'N/A')
    }

def process_records_for_display(records):
    """Process and organize records for better display."""
    if not records:
        logger.warning("No records provided for processing.")
        return []

    student_records = {}
    for record in records:
        try:
            # Ensure record is a dictionary
            if not isinstance(record, dict):
                logger.warning(f"Skipping non-dict record: {type(record)}")
                continue
                
            index_number = record.get('index_number', 'unknown')
            if index_number not in student_records:
                student_records[index_number] = {
                    'profile': process_student_profile(record),
                    'grades': []
                }

            if 'course_code' in record and record.get('score') is not None:
                student_records[index_number]['grades'].append(process_student_grades(record))
        except Exception as e:
            logger.error(f"Error processing record for index_number {record.get('index_number', 'unknown') if isinstance(record, dict) else 'unknown'}: {e}")

    # Convert to list format expected by report functions
    result = []
    for index_number, data in student_records.items():
        result.append(data)
    
    logger.info(f"Processed {len(result)} student records.")
    return result

def export_summary_report_txt(records: list, filename="summary_report.txt"):
    """
    Exports a detailed summary report of all student records to a text file in tabular format.
    Returns the file path of the generated TXT file.
    """
    try:
        # Ensure the filename has the correct extension
        if not filename.endswith('.txt'):
            filename += '.txt'
            
        header_info = get_report_header_info()
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(f"{'='*80}\n")
            f.write(f"{'STUDENT RESULTS SUMMARY REPORT':^80}\n")
            f.write(f"{'='*80}\n\n")
            f.write(f"Generated By: {header_info['generated_by']}\n")
            f.write(f"Generation Time: {header_info['generation_time']}\n")
            f.write(f"Session Duration: {header_info['session_duration']}\n")
            f.write(f"{'='*80}\n\n")

            if not records:
                f.write("No student records available.\n")
                logger.info(f"Generated empty summary report: {filename}")
                return filename

            # Collect valid scores for statistics - with robust validation
            valid_scores = []
            for student in records:
                # Validate student record structure
                if not isinstance(student, dict):
                    continue
                    
                if 'grades' not in student or not isinstance(student['grades'], list):
                    continue
                    
                for grade in student['grades']:
                    if not isinstance(grade, dict):
                        continue
                        
                    score = grade.get('score')
                    if score is not None and isinstance(score, (int, float)):
                        valid_scores.append(score)

            # Summary statistics
            total_students = len([s for s in records if isinstance(s, dict) and 'profile' in s])
            if valid_scores:
                average_score = sum(valid_scores) / len(valid_scores)
                highest_score = max(valid_scores)
                lowest_score = min(valid_scores)
            else:
                average_score = highest_score = lowest_score = 0

            f.write(f"Total Students: {total_students}\n")
            f.write(f"Average Score: {average_score:.2f}\n")
            f.write(f"Highest Score: {highest_score}\n")
            f.write(f"Lowest Score: {lowest_score}\n")
            f.write(f"{'='*80}\n\n")

            # Grade distribution - with robust validation
            grade_distribution = {"A": 0, "B": 0, "C": 0, "D": 0, "F": 0}
            for student in records:
                if not isinstance(student, dict) or 'grades' not in student or not isinstance(student['grades'], list):
                    continue
                    
                for grade in student['grades']:
                    if not isinstance(grade, dict):
                        continue
                        
                    grade_value = grade.get('grade', "F")
                    if grade_value in grade_distribution:
                        grade_distribution[grade_value] += 1

            f.write("Grade Distribution:\n")
            for grade, count in grade_distribution.items():
                f.write(f"{grade}: {count}\n")
            f.write(f"{'='*80}\n\n")

            # Tabular header
            f.write(f"{'Name':<25}{'Index':<15}{'Course':<15}{'Score':<10}{'Grade':<10}\n")
            f.write(f"{'-'*80}\n")

            # Sort records safely
            def safe_sort_key(x):
                try:
                    if not isinstance(x, dict):
                        return ("F", "Unknown")
                        
                    if 'grades' not in x or not isinstance(x['grades'], list) or not x['grades']:
                        grade = "F"
                    else:
                        grade = x['grades'][0].get('grade', "F") if isinstance(x['grades'][0], dict) else "F"
                    
                    if 'profile' not in x or not isinstance(x['profile'], dict):
                        name = "Unknown"
                    else:
                        name = x['profile'].get('full_name', "Unknown")
                    
                    return (grade, name)
                except Exception:
                    return ("F", "Unknown")
            
            try:
                sorted_records = sorted([r for r in records if isinstance(r, dict)], key=safe_sort_key)
            except Exception as e:
                logger.warning(f"Error sorting records: {e}")
                sorted_records = [r for r in records if isinstance(r, dict)]

            for student_data in sorted_records:
                # Validate student data structure
                if not isinstance(student_data, dict) or 'profile' not in student_data or not isinstance(student_data['profile'], dict):
                    continue
                    
                profile = student_data['profile']
                if 'grades' not in student_data or not isinstance(student_data['grades'], list):
                    continue
                    
                for grade in student_data['grades']:
                    if not isinstance(grade, dict):
                        continue
                        
                    name = profile.get('full_name', 'Unknown')
                    index = profile.get('index_number', 'Unknown')
                    course = grade.get('course_code', 'Unknown')
                    score = grade.get('score', 'N/A')
                    grade_value = grade.get('grade', 'F')
                    
                    f.write(f"{name:<25}{index:<15}{course:<15}{score:<10}{grade_value:<10}\n")

            logger.info(f"Summary report exported to {filename}")
            return filename
    except Exception as e:
        logger.error(f"Error exporting summary report to TXT: {e}")
        # Create a simple error text file to ensure we return a valid file
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(f"{'='*80}\n")
                f.write("ERROR GENERATING REPORT\n")
                f.write(f"{'='*80}\n\n")
                f.write(f"An error occurred: {str(e)}\n")
        except Exception as inner_e:
            logger.error(f"Failed to create error text file: {inner_e}")
            
        # Return the filename even in case of error to maintain consistent return type
        return filename

class PDFReport(FPDF):
    def __init__(self, header_info, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.header_info = header_info
        self.set_auto_page_break(auto=True, margin=15) # Set auto page break

    def header(self):
        self.set_font('Arial', 'B', 15)
        self.cell(0, 10, 'Student Academic Report', 0, 1, 'C')
        self.set_font('Arial', '', 10)
        self.cell(0, 5, f"Generated By: {self.header_info['generated_by']}", 0, 1, 'C')
        self.cell(0, 5, f"Generation Time: {self.header_info['generation_time']}", 0, 1, 'C')
        self.cell(0, 5, f"Session Duration: {self.header_info['session_duration']}", 0, 1, 'C')
        self.ln(10)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.cell(0, 10, f'Page {self.page_no()}/{{nb}}', 0, 0, 'C')

    def chapter_title(self, title):
        self.set_font('Arial', 'B', 12)
        self.cell(0, 10, title, 0, 1, 'L')
        self.ln(2)

    def chapter_body(self, body):
        self.set_font('Arial', '', 10)
        self.multi_cell(0, 6, body)
        self.ln()

def export_summary_report_pdf(records: list, filename="summary_report.pdf"):
    """
    Exports a detailed and professional summary report of all student records to a PDF file in tabular format.
    Returns the file path of the generated PDF.
    """
    try:
        # Ensure the filename has the correct extension
        if not filename.endswith('.pdf'):
            filename += '.pdf'
            
        header_info = get_report_header_info()
        pdf = PDFReport(header_info)
        pdf.alias_nb_pages()
        pdf.add_page()
        pdf.set_left_margin(20)
        pdf.set_right_margin(20)

        # Add a professional header
        pdf.set_font('Arial', 'B', 16)
        pdf.cell(0, 10, 'Student Results Summary Report', 0, 1, 'C')
        pdf.set_font('Arial', 'I', 10)
        pdf.cell(0, 10, f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", 0, 1, 'C')
        pdf.ln(10)

        if not records:
            pdf.set_font('Arial', '', 12)
            pdf.cell(0, 10, "No student records available.", 0, 1, 'C')
            pdf.ln(10)
            pdf.set_font('Arial', '', 10)
            pdf.cell(0, 10, "This could mean:", 0, 1, 'L')
            pdf.cell(0, 10, "- No students have been added to the system", 0, 1, 'L')
            pdf.cell(0, 10, "- No grades have been recorded yet", 0, 1, 'L')
            pdf.cell(0, 10, "- Database connection issues", 0, 1, 'L')
            logger.info(f"Generated empty summary report")
            # Save the PDF to file
            pdf.output(filename)
            return filename

        # Overall summary statistics first
        total_students = len(records)
        total_grades = sum(len(student.get('grades', [])) for student in records)
        
        pdf.set_font('Arial', 'B', 14)
        pdf.cell(0, 10, 'Overall Statistics', 0, 1, 'L')
        pdf.set_font('Arial', '', 12)
        pdf.cell(0, 10, f"Total Students: {total_students}", 0, 1, 'L')
        pdf.cell(0, 10, f"Total Grade Records: {total_grades}", 0, 1, 'L')
        
        # Calculate overall GPA if we have grades
        all_scores = []
        all_grades = []
        for student in records:
            for grade in student.get('grades', []):
                if isinstance(grade, dict):
                    score = grade.get('score')
                    if score is not None and isinstance(score, (int, float)):
                        all_scores.append(score)
                    grade_letter = grade.get('grade')
                    if grade_letter:
                        all_grades.append(grade_letter)
        
        if all_scores:
            avg_score = sum(all_scores) / len(all_scores)
            pdf.cell(0, 10, f"Overall Average Score: {avg_score:.2f}", 0, 1, 'L')
        
        # Grade distribution
        if all_grades:
            grade_counts = Counter(all_grades)
            pdf.ln(5)
            pdf.set_font('Arial', 'B', 12)
            pdf.cell(0, 10, 'Grade Distribution:', 0, 1, 'L')
            pdf.set_font('Arial', '', 10)
            for grade in ['A', 'B', 'C', 'D', 'F']:
                count = grade_counts.get(grade, 0)
                percentage = (count / len(all_grades)) * 100 if all_grades else 0
                pdf.cell(0, 8, f"Grade {grade}: {count} students ({percentage:.1f}%)", 0, 1, 'L')
        
        pdf.ln(10)

        # Group records by course with robust validation
        courses = {}
        for student in records:
            # Validate student record structure
            if not isinstance(student, dict):
                continue
                
            if 'grades' not in student or not isinstance(student['grades'], list):
                continue
                
            if 'profile' not in student or not isinstance(student['profile'], dict):
                continue
                
            for grade in student['grades']:
                if not isinstance(grade, dict):
                    continue
                    
                course_code = grade.get('course_code')
                if not course_code:  # Skip if no course code
                    continue
                    
                if course_code not in courses:
                    courses[course_code] = []
                    
                # Get student data safely
                student_data = {
                    'name': student['profile'].get('full_name', 'Unknown'),
                    'index': student['profile'].get('index_number', 'Unknown'),
                    'score': grade.get('score', 0),
                    'grade': grade.get('grade', 'F')
                }
                courses[course_code].append(student_data)

        # Iterate through courses and add sections
        for course_code, students in courses.items():
            if not students:  # Skip empty courses
                continue
                
            pdf.set_font('Arial', 'B', 14)
            pdf.cell(0, 10, f"Course: {course_code}", 0, 1, 'L')

            # Course statistics - safely calculate
            try:
                valid_scores = []
                for student in students:
                    score = student.get('score')
                    if score is not None and isinstance(score, (int, float)):
                        valid_scores.append(score)
                        
                if valid_scores:
                    average_score = sum(valid_scores) / len(valid_scores)
                    highest_score = max(valid_scores)
                    lowest_score = min(valid_scores)
                else:
                    average_score = highest_score = lowest_score = 0
            except Exception as e:
                logger.warning(f"Error calculating course statistics: {e}")
                average_score = highest_score = lowest_score = 0

            pdf.set_font('Arial', '', 12)
            pdf.cell(0, 10, f"Average Score: {average_score:.2f}", 0, 1, 'L')
            pdf.cell(0, 10, f"Highest Score: {highest_score}", 0, 1, 'L')
            pdf.cell(0, 10, f"Lowest Score: {lowest_score}", 0, 1, 'L')
            pdf.ln(5)

            # Tabular header
            pdf.set_font('Arial', 'B', 12)
            pdf.cell(50, 10, "Name", 1, 0, 'C')
            pdf.cell(30, 10, "Index", 1, 0, 'C')
            pdf.cell(20, 10, "Score", 1, 0, 'C')
            pdf.cell(20, 10, "Grade", 1, 1, 'C')

            # Add student data with color coding for grades
            pdf.set_font('Arial', '', 10)
            for student in students:
                if not isinstance(student, dict):
                    continue
                    
                grade_value = student.get('grade', 'F')
                grade_color = {
                    'A': (0, 128, 0),  # Green
                    'B': (0, 0, 255),  # Blue
                    'C': (255, 255, 0),  # Yellow
                    'D': (255, 165, 0),  # Orange
                    'F': (255, 0, 0)   # Red
                }.get(grade_value, (0, 0, 0))  # Default to black

                pdf.set_text_color(*grade_color)
                pdf.cell(50, 10, str(student.get('name', 'Unknown')), 1, 0, 'C')
                pdf.cell(30, 10, str(student.get('index', 'Unknown')), 1, 0, 'C')
                pdf.cell(20, 10, str(student.get('score', 'N/A')), 1, 0, 'C')
                pdf.cell(20, 10, str(grade_value), 1, 1, 'C')

            pdf.set_text_color(0, 0, 0)  # Reset to black
            pdf.ln(10)

        logger.info(f"Summary report generated successfully: {filename}")
        # Save the PDF to file
        pdf.output(filename)
        return filename
    except Exception as e:
        logger.error(f"Error exporting summary report to PDF: {e}")
        # Create a simple error PDF to ensure we return a valid file
        try:
            error_pdf = PDFReport(get_report_header_info())
            error_pdf.alias_nb_pages()
            error_pdf.add_page()
            error_pdf.set_font('Arial', 'B', 16)
            error_pdf.cell(0, 10, 'Error Generating Report', 0, 1, 'C')
            error_pdf.set_font('Arial', '', 12)
            error_pdf.cell(0, 10, f"An error occurred: {str(e)}", 0, 1, 'C')
            error_pdf.output(filename)
        except Exception as inner_e:
            logger.error(f"Failed to create error PDF: {inner_e}")
            
        # Return the filename even in case of error to maintain consistent return type
        return filename

def export_personal_academic_report(student_index, format_type='pdf'):
    """
    Generates a personal academic report for a specific student.
    Can export to PDF or TXT.
    Returns the report content - bytes for PDF or string for TXT.
    """
    logger.info(f"generating personal academic report for {student_index} in {format_type} format")
    try:
        conn = connect_to_db()
        if conn:
            student_data = fetch_student_by_index_number(conn, student_index)
            conn.close()

            if student_data and student_data.get('grades') is not None:
                # Transform the data structure to match what the report functions expect
                student_record = {
                    'profile': {
                        'student_id': student_data.get('student_id'),
                        'index_number': student_data.get('index_number'),
                        'full_name': student_data.get('full_name'),
                        'dob': student_data.get('dob'),
                        'gender': student_data.get('gender'),
                        'contact_email': student_data.get('contact_email'),
                        'contact_phone': student_data.get('contact_phone'),
                        'program': student_data.get('program'),
                        'year_of_study': student_data.get('year_of_study'),
                        'created_at': student_data.get('created_at'),
                        'updated_at': student_data.get('updated_at')
                    },
                    'grades': list(student_data.get('grades', []))
                }
                
                # Convert to list format expected by report functions
                student_records = [student_record]
                
                # For API endpoints, we don't need to save to file, just return the content
                if format_type.lower() == 'pdf':
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    filename = f"personal_report_{student_index}_{timestamp}.pdf"
                    pdf_path = export_summary_report_pdf(student_records, filename)
                    if not pdf_path or not os.path.exists(pdf_path):
                        logger.error(f"Failed to generate PDF report for student {student_index}")
                        return None
                    return pdf_path
                else:
                    # For text reports, we still need a filename for the function to work
                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    filename = f"personal_report_{student_index}_{timestamp}.txt"
                    result = export_summary_report_txt(student_records, filename)
                    # If successful, read the file content and return it
                    if result and os.path.exists(filename):
                        try:
                            with open(filename, 'r', encoding='utf-8') as f:
                                content = f.read()
                            # Clean up the file after reading
                            try:
                                os.remove(filename)
                            except Exception as e:
                                logger.warning(f"Failed to remove temporary file {filename}: {e}")
                            return content
                        except Exception as e:
                            logger.error(f"Error reading file {filename}: {e}")
                            return None
                    logger.error(f"Failed to generate TXT report for student {student_index}")
                    return None
            else:
                logger.warning(f"no data found for student {student_index}")
                return None
        else:
            logger.error("database connection failed for personal report")
            return None
    except Exception as e:
        logger.error(f"error generating personal report for {student_index}: {e}")
        return None

def export_admin_comprehensive_report(records, format_type='txt'):
    """Export comprehensive administrative report
    Returns the report content - bytes for PDF or string for TXT.
    """
    try:
        if format_type.lower() == 'pdf':
            return export_summary_report_pdf(records)
        else:
            # For text reports, we still need a filename for the function to work
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"admin_comprehensive_report_{timestamp}.txt"
            result = export_summary_report_txt(records, filename)
            # If successful, read the file content and return it
            if result and os.path.exists(filename):
                with open(filename, 'r', encoding='utf-8') as f:
                    content = f.read()
                # Clean up the file after reading
                try:
                    os.remove(filename)
                except Exception as e:
                    logger.warning(f"Failed to remove temporary file {filename}: {e}")
                return content
            # Return None instead of filename if we couldn't read it to prevent looping
            return None
    except Exception as e:
        logger.error(f"error generating admin comprehensive report: {e}")
        return None

def build_summary_file(format_type='txt'):
    """Fallback builder for summary report files when primary path-based generation fails.
    Returns tuple (content_bytes, filename, media_type) or None on unrecoverable failure.
    This re-fetches records directly from the database to avoid coupling with prior call state.
    """
    try:
        from db import connect_to_db, fetch_all_records
        conn = connect_to_db()
        if not conn:
            logger.error("build_summary_file: failed to connect to DB")
            return None
        raw = fetch_all_records(conn)
        conn.close()
        records = aggregate_student_data_for_reports(raw)
        ts = datetime.now().strftime('%Y%m%d_%H%M%S')
        format_type = format_type.lower()
        if format_type == 'pdf':
            filename = f"summary_report_{ts}.pdf"
            path = export_summary_report_pdf(records, filename)
            media = 'application/pdf'
        elif format_type == 'txt':
            filename = f"summary_report_{ts}.txt"
            path = export_summary_report_txt(records, filename)
            media = 'text/plain'
        elif format_type == 'csv':
            # Reuse existing csv exporter if present else simple inline writer
            try:
                from report_utils import export_summary_report_csv  # circular if we rename; safe if exists
                filename = f"summary_report_{ts}.csv"
                path = export_summary_report_csv(records, filename)
            except Exception:
                # Minimal CSV inline
                filename = f"summary_report_{ts}.csv"
                headers = ['index_number','full_name','program','num_grades']
                import csv
                with open(filename,'w',newline='',encoding='utf-8') as f:
                    w = csv.writer(f)
                    w.writerow(headers)
                    for student in records:
                        profile = student.get('profile',{}) if isinstance(student, dict) else {}
                        grades = student.get('grades',[]) if isinstance(student, dict) else []
                        w.writerow([
                            profile.get('index_number',''),
                            profile.get('full_name',''),
                            profile.get('program',''),
                            len(grades)
                        ])
                path = filename
            media = 'text/csv'
        else:
            logger.error(f"build_summary_file: unsupported format {format_type}")
            return None

        if not path or not os.path.exists(path):
            logger.error(f"build_summary_file: exporter did not produce path for {format_type}")
            return None
        with open(path, 'rb') as f:
            data = f.read()
        try:
            os.remove(path)
        except Exception as e:
            logger.warning(f"build_summary_file: could not remove temp file {path}: {e}")
        if not data:
            logger.error("build_summary_file: empty data produced")
            return None
        return data, filename, media
    except Exception as e:
        logger.exception(f"build_summary_file unexpected error: {e}")
        return None

def fetch_all_records_with_admin_check(conn):
    """Fetch all records with admin validation."""
    current_user = session_manager.get_current_user()
    if not current_user or current_user['role'] != 'admin':
        logger.warning("Unauthorized access attempt to fetch all records.")
        return None

    return fetch_all_records(conn)

def aggregate_student_data_for_reports(db_records):
    """
    Processes database records into a format suitable for report generation.
    Returns a list of student records with profile and grades information.
    """
    if not db_records:
        logger.warning("No records provided for report aggregation.")
        return []

    # Handle the structure returned by fetch_all_records
    if isinstance(db_records, dict) and 'students' in db_records and 'grades' in db_records:
        students = db_records['students']
        grades = db_records['grades']
        
        # Create a mapping of students by index_number
        students_by_index = {}
        for student in students:
            if isinstance(student, dict) and 'index_number' in student:
                students_by_index[student['index_number']] = student
        
        # Group grades by student index_number
        grades_by_student = {}
        for grade in grades:
            if isinstance(grade, dict) and 'index_number' in grade:
                index_num = grade['index_number']
                if index_num not in grades_by_student:
                    grades_by_student[index_num] = []
                
                # Add grade letter if not present
                if 'grade' not in grade and 'score' in grade:
                    try:
                        grade['grade'] = calculate_grade(grade['score'])
                    except Exception as e:
                        logger.warning(f"Error calculating grade for score {grade['score']}: {e}")
                        grade['grade'] = 'F'
                        
                grades_by_student[index_num].append(grade)
        
        # Combine students with their grades
        records_list = []
        for index_num, student_profile in students_by_index.items():
            student_record = {
                'profile': student_profile,
                'grades': grades_by_student.get(index_num, [])
            }
            records_list.append(student_record)
        
        logger.info(f"Aggregated {len(records_list)} student records for report generation.")
        return records_list
    else:
        # Fallback to original processing if different structure
        logger.warning("Unexpected data structure, attempting fallback processing")
        if isinstance(db_records, list):
            return process_records_for_display(db_records)
        else:
            logger.error(f"Cannot process data structure: {type(db_records)}")
            return []

# Enhanced Export Functions for Excel and CSV

def export_summary_report_excel(records: list, filename="summary_report.xlsx"):
    """
    Export a comprehensive summary report to Excel format with multiple sheets.
    """
    try:
        if not filename.endswith('.xlsx'):
            filename += '.xlsx'
        
        # Ensure absolute path in current working directory
        import os
        if not os.path.isabs(filename):
            filename = os.path.abspath(filename)
        
        logger.info(f"Starting Excel export to: {filename}")
        
        header_info = get_report_header_info()
        
        # Helper function to clean text for Excel
        def clean_text(text):
            if text is None:
                return ''
            text = str(text)
            # Remove or replace problematic characters
            text = text.replace('\x00', '').replace('\r\n', ' ').replace('\n', ' ').replace('\r', ' ')
            # Limit text length to avoid Excel cell limits
            return text[:32767] if len(text) > 32767 else text
        
        # Create a workbook with xlsxwriter for better formatting
        logger.info(f"Creating Excel workbook: {filename}")
        workbook = xlsxwriter.Workbook(filename, {'remove_timezone': True})
        
        # Define formats
        header_format = workbook.add_format({
            'bold': True,
            'font_size': 14,
            'bg_color': '#4472C4',
            'font_color': 'white',
            'align': 'center'
        })
        
        subheader_format = workbook.add_format({
            'bold': True,
            'bg_color': '#D9E2F3',
            'border': 1
        })
        
        data_format = workbook.add_format({
            'border': 1,
            'align': 'left'
        })
        
        number_format = workbook.add_format({
            'border': 1,
            'num_format': '0.00'
        })
        
        # Sheet 1: Summary Statistics
        summary_sheet = workbook.add_worksheet('Summary Statistics')
        
        # Write header information
        summary_sheet.merge_range(0, 0, 0, 4, 'STUDENT RESULTS SUMMARY REPORT', header_format)
        
        summary_sheet.write('A3', 'Generated By:', subheader_format)
        summary_sheet.write('B3', clean_text(header_info['generated_by']), data_format)
        summary_sheet.write('A4', 'Generation Time:', subheader_format)
        summary_sheet.write('B4', clean_text(header_info['generation_time']), data_format)
        summary_sheet.write('A5', 'Session Duration:', subheader_format)
        summary_sheet.write('B5', clean_text(header_info['session_duration']), data_format)
        
        # Calculate statistics
        valid_scores = []
        total_students = len([s for s in records if isinstance(s, dict) and 'profile' in s])
        
        for student in records:
            if isinstance(student, dict) and 'grades' in student:
                for grade in student['grades']:
                    if isinstance(grade, dict):
                        score = grade.get('score')
                        if score is not None and isinstance(score, (int, float)):
                            valid_scores.append(score)
        
        # Write statistics
        summary_sheet.write('A7', 'STATISTICS', subheader_format)
        summary_sheet.write('A8', 'Total Students:', subheader_format)
        summary_sheet.write('B8', total_students, data_format)
        
        if valid_scores:
            summary_sheet.write('A9', 'Average Score:', subheader_format)
            summary_sheet.write('B9', sum(valid_scores) / len(valid_scores), number_format)
            summary_sheet.write('A10', 'Highest Score:', subheader_format)
            summary_sheet.write('B10', max(valid_scores), number_format)
            summary_sheet.write('A11', 'Lowest Score:', subheader_format)
            summary_sheet.write('B11', min(valid_scores), number_format)
        
        # Grade distribution
        grade_counts = {"A": 0, "B": 0, "C": 0, "D": 0, "F": 0}
        for score in valid_scores:
            grade = calculate_grade(score)
            if grade in grade_counts:
                grade_counts[grade] += 1
        
        summary_sheet.write('A13', 'GRADE DISTRIBUTION', subheader_format)
        row = 14
        for grade, count in grade_counts.items():
            summary_sheet.write(f'A{row}', f'Grade {grade}:', subheader_format)
            summary_sheet.write(f'B{row}', count, data_format)
            row += 1
        
        # Sheet 2: Student Details
        students_sheet = workbook.add_worksheet('Student Details')
        
        # Headers for student details
        headers = ['Index Number', 'Full Name', 'Program', 'Year of Study', 'DOB', 'Gender', 'Email', 'Average Score', 'Overall Grade']
        for col, header in enumerate(headers):
            students_sheet.write(0, col, header, subheader_format)
        
        # Student data
        row = 1
        for student in records:
            if isinstance(student, dict) and 'profile' in student:
                profile = student['profile']
                grades = student.get('grades', [])
                
                # Calculate student average
                student_scores = [g.get('score') for g in grades if isinstance(g, dict) and g.get('score') is not None and isinstance(g.get('score'), (int, float))]
                valid_scores = [score for score in student_scores if score is not None and isinstance(score, (int, float))]
                avg_score = sum(valid_scores) / len(valid_scores) if valid_scores else 0
                try:
                    overall_grade = calculate_grade(avg_score) if avg_score > 0 else 'N/A'
                except Exception as e:
                    logger.warning(f"Error calculating overall grade for average {avg_score}: {e}")
                    overall_grade = 'N/A'
                
                students_sheet.write(row, 0, profile.get('index_number', ''), data_format)
                students_sheet.write(row, 1, profile.get('full_name', profile.get('name', '')), data_format)  # Fixed field mapping
                students_sheet.write(row, 2, profile.get('program', ''), data_format)
                students_sheet.write(row, 3, profile.get('year_of_study', ''), data_format)
                students_sheet.write(row, 4, profile.get('dob', ''), data_format)
                students_sheet.write(row, 5, profile.get('gender', ''), data_format)
                students_sheet.write(row, 6, profile.get('contact_email', ''), data_format)
                students_sheet.write(row, 7, avg_score, number_format)
                students_sheet.write(row, 8, overall_grade, data_format)
                row += 1
        
        # Sheet 3: Detailed Grades
        grades_sheet = workbook.add_worksheet('Detailed Grades')
        
        # Headers for grades
        grade_headers = ['Index Number', 'Student Name', 'Course Code', 'Score', 'Grade']
        for col, header in enumerate(grade_headers):
            grades_sheet.write(0, col, header, subheader_format)
        
        # Grade data
        row = 1
        for student in records:
            if isinstance(student, dict):
                profile = student.get('profile', {})
                grades = student.get('grades', [])
                
                for grade in grades:
                    if isinstance(grade, dict):
                        score = grade.get('score')
                        try:
                            grade_letter = calculate_grade(score) if score is not None else 'N/A'
                        except Exception as e:
                            logger.warning(f"Error calculating grade letter for score {score}: {e}")
                            grade_letter = 'N/A'
                        
                        grades_sheet.write(row, 0, clean_text(profile.get('index_number', '')), data_format)
                        grades_sheet.write(row, 1, clean_text(profile.get('full_name', profile.get('name', ''))), data_format)  # Fixed field mapping
                        grades_sheet.write(row, 2, clean_text(grade.get('course_code', '')), data_format)
                        grades_sheet.write(row, 3, score if score is not None else '', number_format if score is not None else data_format)
                        grades_sheet.write(row, 4, clean_text(grade_letter), data_format)
                        row += 1
        
        # Auto-adjust column widths
        for sheet in [summary_sheet, students_sheet, grades_sheet]:
            sheet.set_column('A:Z', 15)
        
        # Close workbook properly
        logger.info("Closing Excel workbook...")
        workbook.close()
        logger.info(f"Excel workbook closed successfully")
        
        # Verify file was created and is accessible
        import os
        logger.info(f"Checking if file exists: {filename}")
        if not os.path.exists(filename):
            logger.error(f"Excel file was not created: {filename}")
            # List directory contents for debugging
            dir_path = os.path.dirname(filename)
            if os.path.exists(dir_path):
                logger.error(f"Directory {dir_path} contents: {os.listdir(dir_path)}")
            return None
            
        file_size = os.path.getsize(filename)
        logger.info(f"Excel file size: {file_size} bytes")
        if file_size == 0:
            logger.error(f"Excel file is empty: {filename}")
            return None
        
        logger.info(f"Excel report generated successfully: {filename} (Size: {file_size} bytes)")
        return filename
        
    except Exception as e:
        logger.error(f"Error generating Excel report: {str(e)}")
        logger.error(f"Exception type: {type(e).__name__}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")
        return None

def export_summary_report_csv(records: list, filename="summary_report.csv"):
    """
    Export a summary report to CSV format.
    """
    try:
        if not filename.endswith('.csv'):
            filename += '.csv'
        
        header_info = get_report_header_info()
        
        # Prepare data for CSV
        csv_data = []
        
        # Add header information as comments
        csv_data.append(['# STUDENT RESULTS SUMMARY REPORT'])
        csv_data.append([f'# Generated By: {header_info["generated_by"]}'])
        csv_data.append([f'# Generation Time: {header_info["generation_time"]}'])
        csv_data.append([f'# Session Duration: {header_info["session_duration"]}'])
        csv_data.append([''])  # Empty row
        
        # Headers
        csv_data.append(['Index Number', 'Full Name', 'Program', 'Year of Study', 'DOB', 'Gender', 'Email', 'Course Code', 'Score', 'Grade', 'Average Score', 'Overall Grade'])
        
        # Student data
        for student in records:
            if isinstance(student, dict) and 'profile' in student:
                profile = student['profile']
                grades = student.get('grades', [])
                
                # Calculate student average
                student_scores = [g.get('score') for g in grades if isinstance(g, dict) and g.get('score') is not None and isinstance(g.get('score'), (int, float))]
                valid_scores = [score for score in student_scores if isinstance(score, (int, float))]
                avg_score = sum(valid_scores) / len(valid_scores) if valid_scores else 0
                try:
                    overall_grade = calculate_grade(avg_score) if avg_score > 0 else 'N/A'
                except Exception as e:
                    logger.warning(f"Error calculating overall grade for average {avg_score}: {e}")
                    overall_grade = 'N/A'
                
                if grades:
                    # One row per grade
                    for grade in grades:
                        if isinstance(grade, dict):
                            score = grade.get('score')
                            try:
                                grade_letter = calculate_grade(score) if score is not None else 'N/A'
                            except Exception as e:
                                logger.warning(f"Error calculating grade letter for score {score}: {e}")
                                grade_letter = 'N/A'
                            
                            csv_data.append([
                                profile.get('index_number', ''),
                                profile.get('full_name', profile.get('name', '')),  # Fixed field mapping
                                profile.get('program', ''),
                                profile.get('year_of_study', ''),
                                profile.get('dob', ''),
                                profile.get('gender', ''),
                                profile.get('contact_email', ''),
                                grade.get('course_code', ''),
                                score if score is not None else '',
                                grade_letter,
                                f'{avg_score:.2f}' if avg_score > 0 else '',
                                overall_grade
                            ])
                else:
                    # Student without grades
                    csv_data.append([
                        profile.get('index_number', ''),
                        profile.get('full_name', profile.get('name', '')),  # Fixed field mapping
                        profile.get('program', ''),
                        profile.get('year_of_study', ''),
                        profile.get('dob', ''),
                        profile.get('gender', ''),
                        profile.get('contact_email', ''),
                        '', '', '', '', ''
                    ])
        
        # Write to CSV
        with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerows(csv_data)
        
        logger.info(f"CSV report generated successfully: {filename}")
        return filename
        
    except Exception as e:
        logger.error(f"Error generating CSV report: {str(e)}")
        return None

def export_academic_transcript_excel(student_index: str, filename=None):
    """
    Export individual student academic transcript to Excel format.
    """
    try:
        if filename is None:
            filename = f"transcript_{student_index}.xlsx"
        elif not filename.endswith('.xlsx'):
            filename += '.xlsx'
        
        # Fetch student data
        conn = connect_to_db()
        if not conn:
            logger.error("Database connection failed")
            return None
        
        try:
            with conn.cursor() as cursor:
                # Get student profile - Fixed column name from date_of_birth to dob
                cursor.execute("""
                    SELECT index_number, full_name, program, year_of_study, 
                           dob, gender, contact_email
                    FROM student_profiles 
                    WHERE index_number = %s
                """, (student_index,))
                
                student_data = cursor.fetchone()
                if not student_data:
                    logger.error(f"Student with index {student_index} not found")
                    return None
                
                # Get student grades - Fixed to use proper table structure
                cursor.execute("""
                    SELECT c.course_code, c.course_title, c.credit_hours,
                           g.score, g.grade, s.semester_name, s.academic_year
                    FROM grades g
                    JOIN courses c ON g.course_id = c.course_id
                    JOIN semesters s ON g.semester_id = s.semester_id
                    JOIN student_profiles sp ON g.index_number = sp.index_number
                    WHERE sp.index_number = %s
                    ORDER BY s.academic_year, s.semester_name, c.course_code
                """, (student_index,))
                
                grades_data = cursor.fetchall()
                
        except Exception as db_error:
            logger.error(f"Database query error: {db_error}")
            return None
        finally:
            conn.close()
        
        # Create workbook
        workbook = xlsxwriter.Workbook(filename)
        
        # Define formats
        title_format = workbook.add_format({
            'bold': True,
            'font_size': 16,
            'align': 'center',
            'bg_color': '#4472C4',
            'font_color': 'white'
        })
        
        header_format = workbook.add_format({
            'bold': True,
            'bg_color': '#D9E2F3',
            'border': 1,
            'align': 'center'
        })
        
        data_format = workbook.add_format({
            'border': 1
        })
        
        number_format = workbook.add_format({
            'border': 1,
            'num_format': '0.00'
        })
        
        # Create worksheet
        worksheet = workbook.add_worksheet('Academic Transcript')
        
        # Title
        worksheet.merge_range(0, 0, 0, 6, 'OFFICIAL ACADEMIC TRANSCRIPT', title_format)
        
        # Student information
        row = 3
        worksheet.merge_range(row-1, 0, row-1, 6, 'Student Information:', header_format)
        
        row += 1
        fields = [
            ('Index Number:', student_data[0]),
            ('Full Name:', student_data[1]),
            ('Program:', student_data[2]),
            ('Year of Study:', student_data[3]),
            ('Date of Birth:', str(student_data[4]) if student_data[4] else ''),
            ('Gender:', student_data[5]),
            ('Email:', student_data[6])
        ]
        
        for field, value in fields:
            worksheet.write(f'A{row}', field, header_format)
            worksheet.write(f'B{row}', value, data_format)
            row += 1
        
        # Academic record
        row += 2
        worksheet.merge_range(row, 0, row, 6, 'Academic Record:', header_format)
        
        row += 1
        headers = ['Course Code', 'Course Title', 'Credit Hours', 'Score', 'Grade', 'Semester', 'Academic Year']
        for col, header in enumerate(headers):
            worksheet.write(row, col, header, header_format)
        
        row += 1
        total_credits = 0
        total_grade_points = 0
        
        for grade_record in grades_data:
            course_code, course_title, credit_hours, score, grade, semester, academic_year = grade_record
            
            worksheet.write(row, 0, course_code or '', data_format)
            worksheet.write(row, 1, course_title or '', data_format)
            worksheet.write(row, 2, credit_hours or 0, data_format)
            worksheet.write(row, 3, score if score is not None else '', number_format if score is not None else data_format)
            worksheet.write(row, 4, grade or '', data_format)
            worksheet.write(row, 5, semester or '', data_format)
            worksheet.write(row, 6, academic_year or '', data_format)
            
            # Calculate GPA components
            if credit_hours and score is not None:
                total_credits += credit_hours
                try:
                    # Use direct grade point mapping; calculate_gpa expects list of dicts with credits
                    grade_point = get_grade_point(score) if score is not None else 0
                    total_grade_points += grade_point * credit_hours
                except Exception as gpa_error:
                    logger.warning(f"Error calculating GPA for score {score}: {gpa_error}")
            
            row += 1
        
        # GPA calculation
        row += 2
        gpa = total_grade_points / total_credits if total_credits > 0 else 0
        worksheet.write(f'A{row}', 'Cumulative GPA:', header_format)
        worksheet.write(f'B{row}', gpa, number_format)
        worksheet.write(f'A{row+1}', 'Total Credits:', header_format)
        worksheet.write(f'B{row+1}', total_credits, data_format)
        
        # Auto-adjust column widths
        worksheet.set_column('A:A', 12)
        worksheet.set_column('B:B', 25)
        worksheet.set_column('C:G', 15)
        
        workbook.close()
        
        logger.info(f"Academic transcript generated successfully: {filename}")
        return filename
        
    except Exception as e:
        logger.error(f"Error generating academic transcript: {str(e)}")
        return None

def export_academic_transcript_pdf(student_index: str, filename=None):
    """Generate a PDF academic transcript for a single student using fpdf2.

    Returns path to generated PDF file or None on failure.
    """
    try:
        from fpdf import FPDF
    except Exception as e:
        logger.error(f"fpdf2 not installed or failed to import: {e}")
        return None
    try:
        if filename is None:
            filename = f"transcript_{student_index}.pdf"
        elif not filename.endswith('.pdf'):
            filename += '.pdf'

        conn = connect_to_db()
        if not conn:
            logger.error("Database connection failed for PDF transcript")
            return None
        try:
            with conn.cursor() as cur:
                cur.execute("""
                    SELECT index_number, full_name, program, year_of_study, dob, gender, contact_email
                    FROM student_profiles WHERE index_number=%s
                """, (student_index,))
                student_row = cur.fetchone()
                if not student_row:
                    logger.warning(f"Student {student_index} not found for PDF transcript")
                    return None
                
                # Convert tuple to dictionary
                student = {
                    'index_number': student_row[0],
                    'full_name': student_row[1], 
                    'program': student_row[2],
                    'year_of_study': student_row[3],
                    'dob': student_row[4],
                    'gender': student_row[5],
                    'contact_email': student_row[6]
                }
                
                cur.execute("""
                    SELECT c.course_code, c.course_title, c.credit_hours, g.score, g.grade,
                           s.semester_name, s.academic_year
                    FROM grades g
                    JOIN courses c ON g.course_id = c.course_id
                    JOIN semesters s ON g.semester_id = s.semester_id
                    JOIN student_profiles sp ON g.student_id = sp.student_id
                    WHERE sp.index_number = %s
                    ORDER BY s.academic_year, s.semester_name, c.course_code
                """, (student_index,))
                grades_rows = cur.fetchall()
                
                # Convert tuples to dictionaries
                grades = []
                for row in grades_rows:
                    grades.append({
                        'course_code': row[0],
                        'course_title': row[1],
                        'credit_hours': row[2],
                        'score': row[3],
                        'grade': row[4],
                        'semester_name': row[5],
                        'academic_year': row[6]
                    })
        finally:
            conn.close()

        pdf = FPDF(format='A4', orientation='P', unit='mm')
        pdf.set_auto_page_break(auto=True, margin=12)
        pdf.add_page()
        pdf.set_font('Helvetica', 'B', 16)
        pdf.set_text_color(40,40,40)
        pdf.cell(0, 10, 'OFFICIAL ACADEMIC TRANSCRIPT', ln=1, align='C')
        pdf.set_font('Helvetica', '', 10)
        pdf.ln(4)
        # Student info box
        info_lines = [
            ('Index Number', student['index_number']),
            ('Full Name', student['full_name']),
            ('Program', student.get('program') or ''),
            ('Year of Study', student.get('year_of_study') or ''),
            ('Date of Birth', str(student.get('dob') or '')),
            ('Gender', student.get('gender') or ''),
            ('Email', student.get('contact_email') or '')
        ]
        for label, value in info_lines:
            pdf.set_font('Helvetica', 'B', 9)
            pdf.cell(32, 5, f"{label}:")
            pdf.set_font('Helvetica', '', 9)
            pdf.cell(0, 5, str(value), ln=1)

        pdf.ln(4)
        pdf.set_font('Helvetica', 'B', 11)
        pdf.cell(0, 7, 'Academic Record', ln=1)
        pdf.set_font('Helvetica', 'B', 8)
        headers = ['Course', 'Title', 'CH', 'Score', 'Grade', 'Semester', 'Year']
        widths = [22, 60, 10, 15, 14, 30, 25]
        for h, w in zip(headers, widths):
            pdf.cell(w, 6, h, border=1, align='C')
        pdf.ln(6)
        pdf.set_font('Helvetica', '', 8)

        total_credits = 0
        total_points = 0.0
        for g in grades:
            # GPA component
            score = g.get('score')
            ch = g.get('credit_hours') or 0
            if score is not None and ch:
                try:
                    gp = get_grade_point(score)
                    total_points += gp * ch
                    total_credits += ch
                except Exception as gp_err:
                    logger.warning(f"Failed to map score {score} to grade point: {gp_err}")
            row_vals = [
                g.get('course_code',''),
                (g.get('course_title') or '')[:40],
                str(ch),
                '' if score is None else f"{score:.2f}",
                g.get('grade') or '',
                g.get('semester_name') or '',
                g.get('academic_year') or ''
            ]
            for val, w in zip(row_vals, widths):
                pdf.cell(w, 5, val, border=1)
            pdf.ln(5)

        pdf.ln(4)
        pdf.set_font('Helvetica', 'B', 9)
        pdf.cell(32, 5, 'Total Credits:')
        pdf.set_font('Helvetica', '', 9)
        pdf.cell(0,5,str(total_credits), ln=1)
        pdf.set_font('Helvetica', 'B', 9)
        pdf.cell(32, 5, 'Cumulative GPA:')
        pdf.set_font('Helvetica', '', 9)
        gpa = round(total_points/total_credits,2) if total_credits>0 else 0.0
        pdf.cell(0,5,f"{gpa:.2f}", ln=1)

        pdf.ln(6)
        pdf.set_font('Helvetica','I',7)
        pdf.multi_cell(0,4,"This document is system generated and valid without signature.")

        try:
            pdf.output(filename)
        except Exception as e:
            logger.error(f"Failed writing PDF transcript: {e}")
            return None
        logger.info(f"PDF academic transcript generated: {filename}")
        return filename
    except Exception as e:
        logger.error(f"Error generating PDF transcript: {e}")
        return None